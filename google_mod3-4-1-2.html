<!DOCTYPE html>

<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>バドミントン動作分析アプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* カスタムCSS */
        body {
            font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
            overflow-x: hidden;
        }
        
        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            .container {
                max-width: 100% !important;
                padding: 0.5rem !important;
                margin: 0 !important;
            }
            
            .text-4xl {
                font-size: 1.875rem !important;
            }
            
            .text-2xl {
                font-size: 1.25rem !important;
            }
            
            .text-xl {
                font-size: 1.125rem !important;
            }
            
            .grid-cols-1.md\:grid-cols-2 {
                grid-template-columns: 1fr !important;
            }
            
            .py-3.px-6 {
                padding: 0.5rem 1rem !important;
            }
            
            .mb-8 {
                margin-bottom: 1rem !important;
            }
            
            .p-4 {
                padding: 0.75rem !important;
            }
            
            .gap-4 {
                gap: 0.75rem !important;
            }
            
            .gap-6 {
                gap: 1rem !important;
            }
            
            .aspect-video {
                aspect-ratio: 16/9;
                max-height: 300px;
            }
            
            .h-48 {
                height: 200px !important;
            }
            
            .flex-wrap {
                flex-wrap: wrap !important;
            }
            
            .text-xs {
                font-size: 0.7rem !important;
            }
        }
        
        /* ガラスモーフィズムテーマ設定 */
        :root {
            --glass-bg: rgba(255, 255, 255, 0.25);
            --glass-border: rgba(255, 255, 255, 0.18);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            --backdrop-blur: blur(8px);
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --text-accent: #667eea;
            --accent-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --surface-glass: rgba(255, 255, 255, 0.1);
            --border-glass: rgba(255, 255, 255, 0.2);
        }
        
        [data-theme="dark"] {
            --glass-bg: rgba(0, 0, 0, 0.25);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            --backdrop-blur: blur(12px);
            --text-primary: #f7fafc;
            --text-secondary: #e2e8f0;
            --text-accent: #90cdf4;
            --accent-gradient: linear-gradient(135deg, #1e3a8a 0%, #3730a3 100%);
            --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            --surface-glass: rgba(255, 255, 255, 0.05);
            --border-glass: rgba(255, 255, 255, 0.1);
        }
        
        [data-theme="blue"] {
            --glass-bg: rgba(59, 130, 246, 0.2);
            --glass-border: rgba(59, 130, 246, 0.3);
            --glass-shadow: 0 8px 32px 0 rgba(59, 130, 246, 0.3);
            --backdrop-blur: blur(10px);
            --text-primary: #1e40af;
            --text-secondary: #3b82f6;
            --text-accent: #1d4ed8;
            --accent-gradient: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
            --bg-gradient: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            --surface-glass: rgba(59, 130, 246, 0.1);
            --border-glass: rgba(59, 130, 246, 0.2);
        }
        
        [data-theme="green"] {
            --glass-bg: rgba(16, 185, 129, 0.2);
            --glass-border: rgba(16, 185, 129, 0.3);
            --glass-shadow: 0 8px 32px 0 rgba(16, 185, 129, 0.3);
            --backdrop-blur: blur(10px);
            --text-primary: #065f46;
            --text-secondary: #047857;
            --text-accent: #10b981;
            --accent-gradient: linear-gradient(135deg, #10b981 0%, #047857 100%);
            --bg-gradient: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            --surface-glass: rgba(16, 185, 129, 0.1);
            --border-glass: rgba(16, 185, 129, 0.2);
        }
        
        /* ガラスモーフィズムの基本スタイル */
        body {
            background: var(--bg-gradient);
            background-attachment: fixed;
            color: var(--text-primary);
            transition: all 0.3s ease;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
            z-index: -1;
            animation: float 20s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-20px) rotate(1deg); }
            66% { transform: translateY(20px) rotate(-1deg); }
        }
        
        .glass-card {
            background: var(--glass-bg);
            backdrop-filter: var(--backdrop-blur);
            -webkit-backdrop-filter: var(--backdrop-blur);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            position: relative;
            overflow: hidden;
        }
        
        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
        }
        
        .theme-bg-secondary {
            background: var(--glass-bg);
            backdrop-filter: var(--backdrop-blur);
            -webkit-backdrop-filter: var(--backdrop-blur);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
        }
        
        .theme-border {
            border-color: var(--border-glass);
        }
        
        .theme-shadow {
            box-shadow: var(--glass-shadow);
        }
        
        .theme-text-secondary {
            color: var(--text-secondary);
        }
        
        .theme-text-accent {
            color: var(--text-accent);
        }
        
        .theme-bg-accent {
            background: var(--accent-gradient);
        }
        
        /* ガラスモーフィズムボタンスタイル */
        .glass-button {
            background: var(--surface-glass);
            backdrop-filter: var(--backdrop-blur);
            -webkit-backdrop-filter: var(--backdrop-blur);
            border: 1px solid var(--border-glass);
            border-radius: 16px;
            padding: 12px 24px;
            color: var(--text-primary);
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .glass-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .glass-button:hover::before {
            left: 100%;
        }
        
        .glass-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        /* テーマ選択ボタン */
        .theme-selector {
            position: fixed;
            top: 24px;
            right: 24px;
            z-index: 1000;
            display: flex;
            gap: 0.5rem;
            background: var(--glass-bg);
            backdrop-filter: var(--backdrop-blur);
            -webkit-backdrop-filter: var(--backdrop-blur);
            padding: 8px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
        }
        
        .theme-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .theme-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }
        
        .theme-btn:hover::after {
            width: 100%;
            height: 100%;
        }
        
        .theme-btn.active {
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }
        
        .theme-btn:hover {
            transform: scale(1.05);
        }
        
        .theme-btn.light {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .theme-btn.dark {
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
        }
        
        .theme-btn.blue {
            background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%);
        }
        
        .theme-btn.green {
            background: linear-gradient(135deg, #10b981 0%, #047857 100%);
        }
        
        /* アニメーション効果 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes bounce {
            0%, 20%, 53%, 80%, 100% { transform: translateY(0); }
            40%, 43% { transform: translateY(-10px); }
            70% { transform: translateY(-5px); }
        }
        
        .animate-fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        .animate-slide-in {
            animation: slideIn 0.6s ease-out;
        }
        
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        .animate-bounce {
            animation: bounce 1s ease-in-out;
        }
        
        /* ガラスモーフィズムボタンのホバーアニメーション */
        .btn-hover {
            background: var(--surface-glass);
            backdrop-filter: var(--backdrop-blur);
            -webkit-backdrop-filter: var(--backdrop-blur);
            border: 1px solid var(--border-glass);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .btn-hover::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        .btn-hover:hover::before {
            left: 100%;
        }
        
        .btn-hover:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        /* ガラスセクションのホバーアニメーション */
        .section-hover {
            transition: all 0.3s ease;
            position: relative;
        }
        
        .section-hover:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
        }
        
        .section-hover::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border-radius: inherit;
        }
        
        .section-hover:hover::after {
            opacity: 1;
        }
        
        /* ローディングアニメーション */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--border-color);
            border-radius: 50%;
            border-top-color: var(--bg-accent);
            animation: spin 1s ease-in-out infinite;
        }
        
        @media (max-width: 480px) {
            .container {
                padding: 0.25rem !important;
            }
            
            .text-4xl {
                font-size: 1.5rem !important;
            }
            
            .text-2xl {
                font-size: 1rem !important;
            }
            
            .py-3.px-6 {
                padding: 0.375rem 0.75rem !important;
            }
            
            .aspect-video {
                max-height: 200px;
            }
            
            .h-48 {
                height: 150px !important;
            }
        }

    /* スライダーのつまみのスタイル */
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #fb923c; /* orange-400 */
        cursor: pointer;
        border-radius: 50%;
        border: 2px solid white;
        box-shadow: 0 0 2px rgba(0,0,0,0.3);
    }

    input[type="range"]::-moz-range-thumb {
        width: 18px; /* Firefoxはborderを内側に描画するため少し小さく */
        height: 18px;
        background: #fb923c;
        cursor: pointer;
        border-radius: 50%;
        border: 2px solid white;
        box-shadow: 0 0 2px rgba(0,0,0,0.3);
    }

    .analysis-canvas {
        border: 1px solid #e5e7eb; /* gray-200 */
        background-color: #f9fafb; /* gray-50 */
    }
    
    .container {
        max-width: 1200px;
        width: 100%;
    }

    h1, h2, h3 {
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    #cropOverlayCanvas {
        touch-action: none; /* スマホでの操作を考慮 */
        cursor: grab;
    }
</style>

</head>

<body class="p-2 sm:p-4 min-h-screen flex items-center justify-center">
    <!-- テーマ選択ボタン -->
    <div class="theme-selector">
        <button class="theme-btn light active" data-theme="light" title="ライトテーマ"></button>
        <button class="theme-btn dark" data-theme="dark" title="ダークテーマ"></button>
        <button class="theme-btn blue" data-theme="blue" title="ブルーテーマ"></button>
        <button class="theme-btn green" data-theme="green" title="グリーンテーマ"></button>
    </div>
    
    <div class="container mx-auto glass-card p-3 sm:p-6 w-full max-w-full">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold theme-text-accent">バドミントン動作分析</h1>
            <p class="theme-text-secondary mt-1">動画から選手の動きを捉え、軌跡とヒートマップで可視化します。</p>
        </header>

<!-- Section 1: Video Upload and Display -->
    <section class="mb-8 p-4 glass-card section-hover animate-fade-in">
        <h2 class="text-2xl font-semibold mb-3 theme-text-accent">1. 動画の準備 
            <button id="helpButton" class="ml-2 text-sm glass-button px-2 py-1">?</button>
        </h2>
        <input type="file" id="fileInput" accept="video/*" class="block w-full text-sm text-slate-500
          file:mr-4 file:py-2 file:px-4
          file:rounded-lg file:border-0
          file:text-sm file:font-semibold
          file:bg-orange-100 file:text-orange-700
          hover:file:bg-orange-200 disabled:opacity-50 transition-colors" disabled>
        <!-- プログレスバー -->
        <div id="progressContainer" class="hidden mb-4">
            <div class="flex justify-between text-sm theme-text-secondary mb-1">
                <span id="progressLabel">処理中...</span>
                <span id="progressPercent">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5">
                <div id="progressBar" class="theme-bg-accent h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
        
        <p id="loadingTxt" class="text-sm theme-text-secondary mt-2">AIモデルを読み込んでいます... 初回は数秒～数十秒かかることがあります。</p>
        
        <div id="videoContainer" class="mt-4 grid grid-cols-1 lg:grid-cols-2 gap-4 items-start">
            <div>
                <h3 class="text-lg font-medium text-gray-700 mb-1">オリジナル動画</h3>
                <video id="video" controls class="w-full rounded-md shadow-md aspect-video hidden bg-gray-200"></video>
            </div>
            <div class="relative">
                <h3 class="text-lg font-medium text-gray-700 mb-1">姿勢推定オーバーレイ</h3>
                <div id="poseCanvasContainer" class="w-full aspect-video">
                    <canvas id="poseCanvas" class="w-full rounded-md shadow-md aspect-video hidden bg-gray-200"></canvas>
                    <canvas id="cropOverlayCanvas" class="absolute top-0 left-0 w-full h-full hidden"></canvas>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 2: Recording Controls -->
    <section class="mb-8 p-4 glass-card text-center section-hover animate-fade-in">
        <h2 class="text-2xl font-semibold mb-3 theme-text-accent">2. 録画と座標取得</h2>
        <div class="flex flex-wrap justify-center gap-2">
            <button id="startButton" class="glass-button disabled:opacity-50" disabled>録画開始</button>
            <button id="stopButton" class="glass-button disabled:opacity-50" disabled>録画停止</button>
            <a id="downloadLink" href="#" download="badminton_analysis.webm" class="hidden glass-button">録画をダウンロード</a>
        </div>
    </section>

    <!-- Section 3: Movement Analysis -->
    <section id="analysisSection" class="mb-6 p-4 glass-card hidden section-hover animate-slide-in">
        <h2 class="text-2xl font-semibold mb-3 theme-text-accent">3. 移動・ショット分析結果</h2>
        
        <div id="correctionControls" class="mb-4 p-4 glass-card">
            <h3 class="text-xl font-semibold mb-2 theme-text-accent">座標の補正</h3>
            <p class="text-sm theme-text-secondary mb-3">動画内のコートの歪みを補正し、より正確な軌跡を表示します。</p>
            <button id="startCropButton" class="glass-button">コートに合わせてトリミング</button>
            <button id="applyCorrectionButton" class="glass-button ml-2 hidden">補正を適用</button>
            <button id="resetCorrectionButton" class="glass-button ml-2 hidden">補正をリセット</button>
            <p id="cropInstructions" class="text-sm text-indigo-700 mt-2 hidden">コートの四隅をドラッグして調整してください。</p>
        </div>

        <button id="analyzeButton" class="glass-button w-full mb-4">分析を開始・更新</button>

        <div id="visualizationControls" class="mt-4 hidden">
            <!-- ショット閾値調整 -->
            <div class="mb-4 p-4 glass-card">
                <h3 class="text-lg font-semibold mb-2 theme-text-accent">ショット検出設定</h3>
                <div class="mb-3">
                    <label for="thresholdSlider" class="block mb-1 text-sm font-medium theme-text-secondary">速度閾値 (ピクセル/秒): <span id="thresholdValue">5000</span></label>
                    <input type="range" id="thresholdSlider" min="500" max="10000" value="5000" step="100" class="w-full h-3 bg-orange-200 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-xs theme-text-secondary mt-1">
                        <span>500</span>
                        <span>10000</span>
                    </div>
                </div>
                <button id="updateThresholdButton" class="glass-button">閾値を更新</button>
            </div>
            
            <div class="mb-4">
                <label for="timeSlider" class="block mb-1 text-sm font-medium theme-text-secondary">表示する時間範囲 (スライダーで調整):</label>
                <input type="range" id="timeSlider" min="0" max="100" value="100" step="0.1" class="w-full h-3 bg-orange-200 rounded-lg appearance-none cursor-pointer">
                <div class="flex justify-between text-xs theme-text-secondary mt-1">
                    <span id="sliderMinTime">0.0s</span>
                    <span id="sliderCurrentTimeLabel" class="font-semibold">現在: <span id="sliderCurrentTime">0.0s</span></span>
                    <span id="sliderMaxTime">0.0s</span>
                </div>
            </div>
            
            <!-- *** ADDED *** Shot shortcut buttons container -->
            <div id="shotButtonsContainer" class="mt-2 mb-6 flex flex-wrap items-center gap-2"></div>
            
            <!-- エクスポート機能 -->
            <div class="mb-4 p-4 glass-card">
                <h3 class="text-lg font-semibold mb-2 theme-text-accent">データエクスポート</h3>
                <div class="flex flex-wrap gap-2">
                    <button id="exportJSONButton" class="glass-button">JSON形式でエクスポート</button>
                    <button id="exportCSVButton" class="glass-button">CSV形式でエクスポート</button>
                    <button id="exportImageButton" class="glass-button">画像をエクスポート</button>
                    <button id="generateReportButton" class="glass-button">レポート生成</button>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-4">
                <div>
                    <h3 class="text-xl font-semibold mb-2 theme-text-accent">移動軌跡</h3>
                    <p class="text-xs theme-text-secondary mb-1">青: 左足首, 赤: 右足首</p>
                    <canvas id="trajectoryCanvas" class="w-full aspect-[1340/610] analysis-canvas rounded-md shadow"></canvas>
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-2 theme-text-accent">ヒートマップ</h3>
                    <p class="text-xs theme-text-secondary mb-1">滞在頻度が高いほど赤く表示</p>
                    <canvas id="heatmapCanvas" class="w-full aspect-[1340/610] analysis-canvas rounded-md shadow"></canvas>
                </div>
                <!-- *** ADDED *** Wrist Velocity Analysis -->
                <div id="wristAnalysisContainer" class="lg:col-span-2 hidden">
                    <h3 class="text-xl font-semibold mb-2 theme-text-accent">手首の速度</h3>
                    <p class="text-xs theme-text-secondary mb-1">青: 左手首, 赤: 右手首。赤い点線はショット判定の速度閾値。</p>
                    <canvas id="wristVelocityCanvas" class="w-full h-48 analysis-canvas rounded-md shadow"></canvas>
                </div>
            </div>
        </div>
    </section>
</div>

<script type="module">
    import {
        PoseLandmarker,
        FilesetResolver,
        DrawingUtils
    } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.10";

    // DOM Elements
    const fileInput = document.getElementById('fileInput');
    const video = document.getElementById('video');
    const poseCanvas = document.getElementById('poseCanvas');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const downloadLink = document.getElementById('downloadLink');
    const loadingTxt = document.getElementById('loadingTxt');
    const analysisSection = document.getElementById('analysisSection');
    const analyzeButton = document.getElementById('analyzeButton');
    const visualizationControls = document.getElementById('visualizationControls');
    const timeSlider = document.getElementById('timeSlider');
    const sliderMinTime = document.getElementById('sliderMinTime');
    const sliderCurrentTime = document.getElementById('sliderCurrentTime');
    const sliderMaxTime = document.getElementById('sliderMaxTime');
    const trajectoryCanvas = document.getElementById('trajectoryCanvas');
    const heatmapCanvas = document.getElementById('heatmapCanvas');
    const correctionControls = document.getElementById('correctionControls');
    const startCropButton = document.getElementById('startCropButton');
    const applyCorrectionButton = document.getElementById('applyCorrectionButton');
    const resetCorrectionButton = document.getElementById('resetCorrectionButton');
    const cropInstructions = document.getElementById('cropInstructions');
    const cropOverlayCanvas = document.getElementById('cropOverlayCanvas');
    const poseCanvasContainer = document.getElementById('poseCanvasContainer');
    
    // *** ADDED *** DOM Elements for Shot Analysis
    const wristAnalysisContainer = document.getElementById('wristAnalysisContainer');
    const wristVelocityCanvas = document.getElementById('wristVelocityCanvas');
    const shotButtonsContainer = document.getElementById('shotButtonsContainer');
    
    // *** ADDED *** DOM Elements for Threshold Control
    const thresholdSlider = document.getElementById('thresholdSlider');
    const thresholdValue = document.getElementById('thresholdValue');
    const updateThresholdButton = document.getElementById('updateThresholdButton');
    
    // *** ADDED *** DOM Elements for Export Functions
    const exportJSONButton = document.getElementById('exportJSONButton');
    const exportCSVButton = document.getElementById('exportCSVButton');
    const exportImageButton = document.getElementById('exportImageButton');
    const generateReportButton = document.getElementById('generateReportButton');

    // Canvas Contexts
    let ctxPose = poseCanvas.getContext('2d');
    let ctxTrajectory = trajectoryCanvas.getContext('2d');
    let ctxHeatmap = heatmapCanvas.getContext('2d');
    let ctxCropOverlay = cropOverlayCanvas.getContext('2d');
    let ctxWristVelocity = wristVelocityCanvas.getContext('2d'); // *** ADDED ***

    // MediaRecorder & PoseLandmarker
    let mediaRecorder;
    let recordedChunks = [];
    let poseLandmarker = null;
    let drawingUtilsPose = null;
    let runningMode = 'VIDEO';
    let lastVideoTime = -1;
    let anklePositions = []; 
    let wristPositions = []; // *** ADDED ***
    let stream = null; 

    // Analysis & Correction State
    const HEATMAP_GRID_SIZE = 25;
    let videoDuration = 0;
    let cropPoints = [];
    let correctedAnklePositions = [];
    let correctedWristPositions = []; // *** ADDED ***
    let shotTimes = []; // *** ADDED ***
    let homographyMatrix = null;
    let isCorrectionApplied = false;
    let isCroppingMode = false;
    let isDragging = false;
    let draggedPointIndex = -1;
    const CROP_HANDLE_RADIUS = 15;
    
    // Badminton court dimensions (for aspect ratio)
    const COURT_WIDTH = 610;
    const COURT_LENGTH = 1340;
    // *** ADDED *** Threshold for shot detection (pixels/second). Needs tuning.
    let SHOT_VELOCITY_THRESHOLD = 5000; // Made this variable to allow dynamic updates 

    async function initPoseLandmarker() {
        try {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.10/wasm"
            );
            poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
                    delegate: "GPU"
                },
                runningMode: runningMode,
                numPoses: 1
            });
            console.log("PoseLandmarker initialized");
            loadingTxt.textContent = "モデル読み込み完了。動画を選択してください。";
            fileInput.disabled = false;
        } catch (err) {
            console.error("Error initializing PoseLandmarker:", err);
            loadingTxt.textContent = "モデル読み込みに失敗しました。ページをリロードしてください。";
        }
    }

    initPoseLandmarker();

    fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const fileURL = URL.createObjectURL(file);
        video.src = fileURL;
        video.style.display = 'block';
        poseCanvas.style.display = 'block';
        
        video.onloadedmetadata = () => {
            videoDuration = video.duration;
            poseCanvas.width = video.videoWidth;
            poseCanvas.height = video.videoHeight;
            cropOverlayCanvas.width = video.videoWidth;
            cropOverlayCanvas.height = video.videoHeight;
            
            [trajectoryCanvas, heatmapCanvas].forEach(cvs => {
                cvs.width = COURT_LENGTH; 
                cvs.height = COURT_WIDTH;
            });
            // *** ADDED *** Set wrist velocity canvas dimensions
            wristVelocityCanvas.width = 1200; // High resolution for sharp text/lines
            wristVelocityCanvas.height = 400;

            drawingUtilsPose = new DrawingUtils(ctxPose);
            startButton.disabled = false;
            
            resetAllAnalysis(); 
            loadingTxt.textContent = "動画の準備ができました。録画を開始できます。";
        };
        video.onerror = () => {
            console.error("Error loading video file.");
            loadingTxt.textContent = "エラー: 動画ファイルの読み込みに失敗しました。";
        }
    });
    
    function resetAllAnalysis() {
        analysisSection.classList.add('hidden');
        visualizationControls.classList.add('hidden');
        correctionControls.style.display = 'none';
        wristAnalysisContainer.classList.add('hidden'); // *** ADDED ***
        stopCroppingMode();
        anklePositions = [];
        wristPositions = []; // *** ADDED ***
        correctedAnklePositions = [];
        correctedWristPositions = []; // *** ADDED ***
        shotTimes = []; // *** ADDED ***
        shotButtonsContainer.innerHTML = ''; // *** ADDED ***
        recordedChunks = [];
        isCorrectionApplied = false;
        homographyMatrix = null;
        downloadLink.classList.add('hidden');
        analyzeButton.disabled = true;
    }

    async function drawFrame() {
        if (!video || video.paused || video.ended || video.readyState < 2) {
            requestAnimationFrame(drawFrame);
            return;
        }
        
        ctxPose.clearRect(0, 0, poseCanvas.width, poseCanvas.height);
        ctxPose.drawImage(video, 0, 0, poseCanvas.width, poseCanvas.height);

        if (poseLandmarker && video.currentTime !== lastVideoTime) {
            const startTimeMs = performance.now();
            lastVideoTime = video.currentTime;

            poseLandmarker.detectForVideo(video, startTimeMs, (result) => {
                if (result.landmarks && result.landmarks.length > 0) {
                    const landmarks = result.landmarks[0];
                    if (drawingUtilsPose) {
                        drawingUtilsPose.drawConnectors(landmarks, PoseLandmarker.POSE_CONNECTIONS, { color: '#FF8A65', lineWidth: 2 });
                        drawingUtilsPose.drawLandmarks(landmarks, { color: '#FFAB91', radius: 3 });
                    }
                    if (mediaRecorder && mediaRecorder.state === "recording") {
                        // Record ankle positions
                        const leftAnkle = landmarks[27];
                        const rightAnkle = landmarks[28];
                        if (leftAnkle && rightAnkle) {
                            anklePositions.push({
                                time: video.currentTime,
                                leftAnkle: { x: leftAnkle.x, y: leftAnkle.y, visibility: leftAnkle.visibility },
                                rightAnkle: { x: rightAnkle.x, y: rightAnkle.y, visibility: rightAnkle.visibility }
                            });
                        }
                        // *** ADDED *** Record wrist positions
                        const leftWrist = landmarks[15];
                        const rightWrist = landmarks[16];
                        if (leftWrist && rightWrist) {
                            wristPositions.push({
                                time: video.currentTime,
                                leftWrist: { x: leftWrist.x, y: leftWrist.y, visibility: leftWrist.visibility },
                                rightWrist: { x: rightWrist.x, y: rightWrist.y, visibility: rightWrist.visibility }
                            });
                        }
                    }
                }
            });
        }
        if (isCroppingMode) {
            drawCropOverlay();
        }
        requestAnimationFrame(drawFrame);
    }
    
    video.addEventListener('play', () => {
        lastVideoTime = -1;
        requestAnimationFrame(drawFrame);
    });
    
    video.addEventListener('ended', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            stopRecording();
        }
    });

    startButton.addEventListener('click', () => {
        if (poseCanvas.captureStream) {
            stream = poseCanvas.captureStream(30);
        } else {
            console.error("captureStream not supported.");
            loadingTxt.textContent = "エラー: お使いのブラウザは録画機能に対応していません。";
            return;
        }

        video.play();
        resetAllAnalysis();
        
        try {
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
        } catch (e) {
             mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
        }
        
        mediaRecorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            downloadLink.href = url;
            downloadLink.classList.remove('hidden');
            
            analysisSection.classList.remove('hidden');
            correctionControls.style.display = 'block'; 
            analyzeButton.disabled = false;
            visualizationControls.classList.add('hidden'); 

            const recordedPositions = anklePositions.length > 0 ? anklePositions : wristPositions;
            if (recordedPositions.length > 0) {
                const maxTime = recordedPositions[recordedPositions.length - 1].time;
                timeSlider.max = maxTime.toFixed(1);
                timeSlider.value = maxTime.toFixed(1);
                sliderMaxTime.textContent = `${maxTime.toFixed(1)}s`;
                sliderCurrentTime.textContent = `${maxTime.toFixed(1)}s`;
            }
            sliderMinTime.textContent = "0.0s";
            loadingTxt.textContent = "録画が完了しました。「分析を開始」または「コートに合わせてトリミング」を行ってください。";
        };
        
        mediaRecorder.start();
        loadingTxt.textContent = "録画中です...";
        startButton.disabled = true;
        stopButton.disabled = false;
    });

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
        }
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null; 
        }
        startButton.disabled = false;
        stopButton.disabled = true;
    }
    stopButton.addEventListener('click', stopRecording);

    analyzeButton.addEventListener('click', () => {
        if (anklePositions.length === 0 && wristPositions.length === 0) {
            loadingTxt.textContent = "情報: 分析データがありません。先に動画を録画してください。";
            return;
        }
        visualizationControls.classList.remove('hidden');
        wristAnalysisContainer.classList.remove('hidden'); // *** ADDED *** Show wrist graph container

        // *** ADDED *** Perform shot detection
        const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
        const velocities = calculateWristVelocities(wristData, isCorrectionApplied);
        shotTimes = detectShots(velocities, SHOT_VELOCITY_THRESHOLD);
        createShotButtons(shotTimes);

        drawAnalysis(parseFloat(timeSlider.value));
        loadingTxt.textContent = "移動分析とショット分析の結果を表示しています。";
    });

    // テーマ切り替え機能
    document.querySelectorAll('.theme-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const theme = btn.dataset.theme;
            if (theme === 'light') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', theme);
            }
            // テーマ設定を保存
            localStorage.setItem('badminton-theme', theme);
        });
    });

    // ページ読み込み時にテーマを復元
    document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('badminton-theme') || 'light';
        if (savedTheme !== 'light') {
            document.documentElement.setAttribute('data-theme', savedTheme);
        }
        document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`[data-theme="${savedTheme}"]`).classList.add('active');
        
        // アニメーション追加
        setTimeout(() => {
            document.querySelectorAll('section:not(.hidden)').forEach((section, index) => {
                section.style.animationDelay = `${index * 0.2}s`;
            });
        }, 100);
    });
    
    // *** ADDED *** Threshold control event listeners
    thresholdSlider.addEventListener('input', () => {
        thresholdValue.textContent = thresholdSlider.value;
    });
    
    updateThresholdButton.addEventListener('click', () => {
        SHOT_VELOCITY_THRESHOLD = parseInt(thresholdSlider.value);
        // Re-run shot detection with new threshold
        if (wristPositions.length > 0 || correctedWristPositions.length > 0) {
            const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
            const velocities = calculateWristVelocities(wristData, isCorrectionApplied);
            shotTimes = detectShots(velocities, SHOT_VELOCITY_THRESHOLD);
            createShotButtons(shotTimes);
            drawAnalysis(parseFloat(timeSlider.value));
            loadingTxt.textContent = `ショット検出閾値を ${SHOT_VELOCITY_THRESHOLD} に更新しました。`;
        }
    });
    
    timeSlider.addEventListener('input', () => {
        const currentTime = parseFloat(timeSlider.value);
        sliderCurrentTime.textContent = `${currentTime.toFixed(1)}s`;
        if (!visualizationControls.classList.contains('hidden')) { 
             drawAnalysis(currentTime);
        }
    });
    
    function drawAnalysis(currentTime) {
        // Draw Ankle Analysis
        const ankleData = isCorrectionApplied ? correctedAnklePositions : anklePositions;
        const filteredAnkleData = ankleData.filter(p => p.time <= currentTime);
        
        [trajectoryCanvas, heatmapCanvas].forEach(canvas => {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if(isCorrectionApplied) {
                drawBadmintonCourt(ctx);
            }
        });

        if (filteredAnkleData.length > 0) {
            drawTrajectory(filteredAnkleData, isCorrectionApplied, trajectoryCanvas);
            drawHeatmap(filteredAnkleData, isCorrectionApplied, heatmapCanvas);
            loadingTxt.textContent = isCorrectionApplied ? "補正後の分析結果を表示中..." : "移動分析結果を表示中...";
        }

        // *** ADDED *** Draw Wrist Analysis
        const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
        const velocities = calculateWristVelocities(wristData, isCorrectionApplied);
        drawWristVelocityGraph(velocities, currentTime);
    }
    
    function drawBadmintonCourt(ctx) {
        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        ctx.fillStyle = '#f0fdf4';
        ctx.fillRect(0, 0, w, h);
        ctx.strokeStyle = '#4b5563';
        ctx.lineWidth = w / 200;
        ctx.strokeRect(0, 0, w, h);
        ctx.beginPath(); ctx.moveTo(w / 2, 0); ctx.lineTo(w / 2, h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(w*0.05, h/2); ctx.lineTo(w*0.95, h/2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(w*0.05, 0); ctx.lineTo(w*0.05, h); ctx.moveTo(w*0.95, 0); ctx.lineTo(w*0.95, h); ctx.moveTo(w/2 + w*0.3, 0); ctx.lineTo(w/2 + w*0.3, h); ctx.moveTo(w/2 - w*0.3, 0); ctx.lineTo(w/2 - w*0.3, h); ctx.stroke();
    }

    function drawTrajectory(positions, isCorrected, canvas) {
        const ctx = canvas.getContext('2d');
        ctx.lineWidth = 2;
        const getCoords = (pos) => isCorrected ? { x: pos.x, y: pos.y } : { x: pos.x * canvas.width, y: pos.y * canvas.height };
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
        ctx.beginPath();
        positions.forEach((p, i) => { if (p.leftAnkle) { const {x, y} = getCoords(p.leftAnkle); if (i === 0 || !positions[i-1].leftAnkle) ctx.moveTo(x, y); else ctx.lineTo(x, y); } });
        ctx.stroke();
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)';
        ctx.beginPath();
        positions.forEach((p, i) => { if (p.rightAnkle) { const {x, y} = getCoords(p.rightAnkle); if (i === 0 || !positions[i-1].rightAnkle) ctx.moveTo(x, y); else ctx.lineTo(x, y); } });
        ctx.stroke();
    }

    function drawHeatmap(positions, isCorrected, canvas) {
        const ctx = canvas.getContext('2d');
        const gridW = canvas.width / HEATMAP_GRID_SIZE;
        const gridH = canvas.height / HEATMAP_GRID_SIZE;
        const heatmapData = Array(HEATMAP_GRID_SIZE).fill(null).map(() => Array(HEATMAP_GRID_SIZE).fill(0));
        let maxHits = 0;
        const getCoords = (pos) => isCorrected ? { x: pos.x, y: pos.y } : { x: pos.x * canvas.width, y: pos.y * canvas.height };
        positions.forEach(p => {
            [p.leftAnkle, p.rightAnkle].forEach(ankle => {
                if (ankle) {
                    const {x, y} = getCoords(ankle);
                    const gridX = Math.floor(x / gridW);
                    const gridY = Math.floor(y / gridH);
                    if (gridX >= 0 && gridX < HEATMAP_GRID_SIZE && gridY >= 0 && gridY < HEATMAP_GRID_SIZE) {
                        heatmapData[gridY][gridX]++;
                        if (heatmapData[gridY][gridX] > maxHits) maxHits = heatmapData[gridY][gridX];
                    }
                }
            });
        });
        if (maxHits === 0) return;
        for (let y = 0; y < HEATMAP_GRID_SIZE; y++) {
            for (let x = 0; x < HEATMAP_GRID_SIZE; x++) {
                if (heatmapData[y][x] > 0) {
                    const intensity = heatmapData[y][x] / maxHits;
                    const g = Math.floor(255 * (1 - intensity));
                    ctx.fillStyle = `rgba(255, ${g}, 0, ${Math.max(0.1, intensity * 0.7)})`;
                    ctx.fillRect(x * gridW, y * gridH, gridW, gridH);
                }
            }
        }
    }
    
    // --- Cropping and Correction Functions ---
    function startCroppingMode() { isCroppingMode = true; cropOverlayCanvas.classList.remove('hidden'); cropInstructions.classList.remove('hidden'); applyCorrectionButton.classList.remove('hidden'); resetCorrectionButton.classList.remove('hidden'); const w = cropOverlayCanvas.width, h = cropOverlayCanvas.height, mX = w * 0.15, mY = h * 0.15; cropPoints = [{ x: mX, y: mY }, { x: w - mX, y: mY }, { x: w - mX, y: h - mY }, { x: mX, y: h - mY }]; drawCropOverlay(); }
    function stopCroppingMode() { isCroppingMode = false; isDragging = false; draggedPointIndex = -1; cropOverlayCanvas.classList.add('hidden'); cropInstructions.classList.add('hidden'); applyCorrectionButton.classList.add('hidden'); resetCorrectionButton.classList.add('hidden');}
    startCropButton.addEventListener('click', () => { if (isCroppingMode) { stopCroppingMode(); startCropButton.textContent = "コートに合わせてトリミング"; } else { startCroppingMode(); startCropButton.textContent = "調整をキャンセル"; }});
    function drawCropOverlay() { if (!isCroppingMode) return; const ctx = ctxCropOverlay; ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); ctx.beginPath(); ctx.moveTo(cropPoints[0].x, cropPoints[0].y); for (let i = 1; i < cropPoints.length; i++) { ctx.lineTo(cropPoints[i].x, cropPoints[i].y); } ctx.closePath(); ctx.fillStyle = "rgba(59, 130, 246, 0.2)"; ctx.fill(); ctx.strokeStyle = "rgba(37, 99, 235, 1)"; ctx.lineWidth = 4; ctx.stroke(); cropPoints.forEach((p, i) => { ctx.beginPath(); ctx.arc(p.x, p.y, CROP_HANDLE_RADIUS, 0, 2 * Math.PI); ctx.fillStyle = (i === draggedPointIndex) ? "#dc2626" : "#2563eb"; ctx.fill(); });}
    cropOverlayCanvas.addEventListener('mousedown', (e) => { if (!isCroppingMode) return; const rect = cropOverlayCanvas.getBoundingClientRect(); const mouseX = (e.clientX - rect.left) * (cropOverlayCanvas.width / rect.width); const mouseY = (e.clientY - rect.top) * (cropOverlayCanvas.height / rect.height); draggedPointIndex = cropPoints.findIndex(p => Math.sqrt((p.x - mouseX)**2 + (p.y - mouseY)**2) < CROP_HANDLE_RADIUS); if (draggedPointIndex !== -1) { isDragging = true; cropOverlayCanvas.style.cursor = 'grabbing'; } });
    cropOverlayCanvas.addEventListener('mousemove', (e) => { if (!isCroppingMode) return; const rect = cropOverlayCanvas.getBoundingClientRect(); const mouseX = (e.clientX - rect.left) * (cropOverlayCanvas.width / rect.width); const mouseY = (e.clientY - rect.top) * (cropOverlayCanvas.height / rect.height); if (isDragging && draggedPointIndex !== -1) { cropPoints[draggedPointIndex] = { x: mouseX, y: mouseY }; drawCropOverlay(); } else { const onHandle = cropPoints.some(p => Math.sqrt((p.x - mouseX)**2 + (p.y - mouseY)**2) < CROP_HANDLE_RADIUS); cropOverlayCanvas.style.cursor = onHandle ? 'grab' : 'default'; } });
    const stopDrag = () => { if (isDragging) { isDragging = false; draggedPointIndex = -1; cropOverlayCanvas.style.cursor = 'grab'; } };
    cropOverlayCanvas.addEventListener('mouseup', stopDrag);
    cropOverlayCanvas.addEventListener('mouseout', stopDrag);
    applyCorrectionButton.addEventListener('click', () => {
        const srcPoints = cropPoints;
        const dstPoints = [{ x: 0, y: 0 }, { x: trajectoryCanvas.width, y: 0 }, { x: trajectoryCanvas.width, y: trajectoryCanvas.height }, { x: 0, y: trajectoryCanvas.height },];
        try {
            homographyMatrix = getHomographyMatrix(srcPoints, dstPoints);
            // *** MODIFIED *** Apply homography to both ankles and wrists
            correctedAnklePositions = applyHomographyToAllPoints(anklePositions, homographyMatrix, poseCanvas.width, poseCanvas.height, 'Ankle');
            correctedWristPositions = applyHomographyToAllPoints(wristPositions, homographyMatrix, poseCanvas.width, poseCanvas.height, 'Wrist');
            isCorrectionApplied = true;
            stopCroppingMode();
            startCropButton.textContent = "コートに合わせてトリミング";
            if (!visualizationControls.classList.contains('hidden')) { drawAnalysis(parseFloat(timeSlider.value)); } else { analyzeButton.click(); }
            loadingTxt.textContent = "座標の補正が適用されました。";
        } catch (error) { console.error("Failed to compute homography:", error); loadingTxt.textContent = "エラー: 座標の補正に失敗しました。四隅が交差しないように指定してください。"; }
    });
    resetCorrectionButton.addEventListener('click', () => { isCorrectionApplied = false; homographyMatrix = null; correctedAnklePositions = []; correctedWristPositions = []; stopCroppingMode(); startCropButton.textContent = "コートに合わせてトリミング"; if (!visualizationControls.classList.contains('hidden')) { drawAnalysis(parseFloat(timeSlider.value)); } loadingTxt.textContent = "座標の補正をリセットしました。"; });
    
    // *** MODIFIED *** A generic function to apply homography based on key prefix
    function applyHomographyToAllPoints(points, H, videoW, videoH, keyPrefix) {
        const leftKey = `left${keyPrefix}`;
        const rightKey = `right${keyPrefix}`;
        return points.map(p => {
            const newP = { time: p.time };
            if (p[leftKey]) {
                const absCoords = { x: p[leftKey].x * videoW, y: p[leftKey].y * videoH };
                newP[leftKey] = applyHomography(absCoords, H);
            }
            if (p[rightKey]) {
                const absCoords = { x: p[rightKey].x * videoW, y: p[rightKey].y * videoH };
                newP[rightKey] = applyHomography(absCoords, H);
            }
            return newP;
        });
    }

    function applyHomography(point, H) { const d = H[6] * point.x + H[7] * point.y + 1; return { x: (H[0] * point.x + H[1] * point.y + H[2]) / d, y: (H[3] * point.x + H[4] * point.y + H[5]) / d }; }
    function getHomographyMatrix(src, dst) { const A = []; for (let i = 0; i < 4; i++) { const { x: sx, y: sy } = src[i]; const { x: dx, y: dy } = dst[i]; A.push([sx, sy, 1, 0, 0, 0, -dx * sx, -dx * sy, -dx]); A.push([0, 0, 0, sx, sy, 1, -dy * sx, -dy * sy, -dy]); } const b = []; for (let i = 0; i < 4; i++) { b.push(dst[i].x); b.push(dst[i].y); } const A_inv = []; for(let i=0; i<8; i++) { A_inv.push([]); for(let j=0; j<8; j++) { const {x:sx, y:sy} = src[Math.floor(i/2)]; if (i % 2 === 0) { A_inv[i][0] = sx; A_inv[i][1] = sy; A_inv[i][2] = 1; A_inv[i][3] = 0; A_inv[i][4] = 0; A_inv[i][5] = 0; A_inv[i][6] = -dst[Math.floor(i/2)].x * sx; A_inv[i][7] = -dst[Math.floor(i/2)].x * sy; } else { A_inv[i][0] = 0; A_inv[i][1] = 0; A_inv[i][2] = 0; A_inv[i][3] = sx; A_inv[i][4] = sy; A_inv[i][5] = 1; A_inv[i][6] = -dst[Math.floor(i/2)].y * sx; A_inv[i][7] = -dst[Math.floor(i/2)].y * sy; } } } const h = gaussianElimination(A_inv, b); if (!h) throw new Error("Matrix is singular."); return [...h, 1]; }
    function gaussianElimination(A, b) { const n = A.length; for (let i = 0; i < n; i++) { let maxRow = i; for (let k = i + 1; k < n; k++) { if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) { maxRow = k; } } [A[i], A[maxRow]] = [A[maxRow], A[i]]; [b[i], b[maxRow]] = [b[maxRow], b[i]]; if (Math.abs(A[i][i]) < 1e-10) return null; for (let k = i + 1; k < n; k++) { A[i][k] /= A[i][i]; } b[i] /= A[i][i]; A[i][i] = 1; for (let k = 0; k < n; k++) { if (k !== i) { const factor = A[k][i]; for (let j = i; j < n; j++) { A[k][j] -= factor * A[i][j]; } b[k] -= factor * b[i]; } } } return b; }

    // --- *** ADDED *** Shot Analysis Functions ---

    function calculateWristVelocities(positions, isCorrected) {
        const velocities = [];
        if (positions.length < 2) return velocities;

        for (let i = 1; i < positions.length; i++) {
            const p1 = positions[i-1];
            const p2 = positions[i];
            const dt = p2.time - p1.time;

            if (dt <= 0) continue;

            let leftV = 0, rightV = 0;

            if (p1.leftWrist && p2.leftWrist) {
                const c1 = isCorrected ? p1.leftWrist : { x: p1.leftWrist.x * poseCanvas.width, y: p1.leftWrist.y * poseCanvas.height };
                const c2 = isCorrected ? p2.leftWrist : { x: p2.leftWrist.x * poseCanvas.width, y: p2.leftWrist.y * poseCanvas.height };
                const distance = Math.sqrt((c2.x - c1.x)**2 + (c2.y - c1.y)**2);
                leftV = distance / dt;
            }
            if (p1.rightWrist && p2.rightWrist) {
                const c1 = isCorrected ? p1.rightWrist : { x: p1.rightWrist.x * poseCanvas.width, y: p1.rightWrist.y * poseCanvas.height };
                const c2 = isCorrected ? p2.rightWrist : { x: p2.rightWrist.x * poseCanvas.width, y: p2.rightWrist.y * poseCanvas.height };
                const distance = Math.sqrt((c2.x - c1.x)**2 + (c2.y - c1.y)**2);
                rightV = distance / dt;
            }
            velocities.push({ time: p2.time, left: leftV, right: rightV });
        }
        return velocities;
    }

    function detectShots(velocities, threshold) {
        const shots = [];
        let isDuringShot = false;

        for (const v of velocities) {
            const maxVelocity = Math.max(v.left, v.right);
            if (maxVelocity >= threshold && !isDuringShot) {
                shots.push(v.time);
                isDuringShot = true;
            } else if (maxVelocity < threshold) {
                isDuringShot = false;
            }
        }
        return shots;
    }

    function drawWristVelocityGraph(velocities, currentTime) {
        const ctx = ctxWristVelocity;
        const canvas = ctx.canvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (velocities.length === 0) return;

        const maxT = velocities.length > 0 ? velocities[velocities.length - 1].time : (anklePositions[anklePositions.length-1]?.time || 1);
        const maxV = Math.max(...velocities.map(v => Math.max(v.left, v.right)), SHOT_VELOCITY_THRESHOLD * 1.2);
        
        const padding = { top: 20, bottom: 40, left: 50, right: 20 };
        const graphWidth = canvas.width - padding.left - padding.right;
        const graphHeight = canvas.height - padding.top - padding.bottom;

        const timeToX = (t) => padding.left + (t / maxT) * graphWidth;
        const velocityToY = (v) => canvas.height - padding.bottom - (v / maxV) * graphHeight;

        ctx.beginPath(); ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1; ctx.moveTo(padding.left, padding.top); ctx.lineTo(padding.left, canvas.height - padding.bottom); ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom); ctx.stroke();
        ctx.fillStyle = '#4b5563'; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillText("Time (s)", canvas.width / 2, canvas.height - padding.bottom + 10);
        ctx.save(); ctx.translate(padding.left - 30, canvas.height / 2); ctx.rotate(-Math.PI / 2); ctx.fillText("手首の速度 (pixels/s)", 0, 0); ctx.restore();

        const thresholdY = velocityToY(SHOT_VELOCITY_THRESHOLD);
        ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.strokeStyle = '#ef4444'; ctx.moveTo(padding.left, thresholdY); ctx.lineTo(canvas.width - padding.right, thresholdY); ctx.stroke();
        ctx.setLineDash([]); ctx.fillStyle = '#ef4444'; ctx.textAlign = 'left'; ctx.fillText(`ショット閾値`, padding.left + 5, thresholdY - 15);

        ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)'; ctx.lineWidth = 2; ctx.beginPath();
        velocities.forEach((v, i) => { const x = timeToX(v.time); const y = velocityToY(v.left); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
        ctx.stroke();
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.8)'; ctx.beginPath();
        velocities.forEach((v, i) => { const x = timeToX(v.time); const y = velocityToY(v.right); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
        ctx.stroke();
        
        const currentX = timeToX(currentTime);
        if (currentX >= padding.left && currentX <= canvas.width - padding.right) {
            ctx.beginPath(); ctx.strokeStyle = '#f97316'; ctx.lineWidth = 1.5; ctx.moveTo(currentX, padding.top); ctx.lineTo(currentX, canvas.height - padding.bottom); ctx.stroke();
        }
    }

    function createShotButtons(shots) {
        shotButtonsContainer.innerHTML = '';
        if (shots.length > 0) {
            const title = document.createElement('span');
            title.className = 'text-sm font-medium text-gray-700 mr-2 self-center';
            title.textContent = 'ショット時点へ移動:';
            shotButtonsContainer.appendChild(title);
        }

        shots.forEach((time, index) => {
            const button = document.createElement('button');
            button.className = 'glass-button text-xs py-1 px-2 transition-transform hover:scale-105';
            button.textContent = `ショット ${index + 1} (${time.toFixed(1)}s)`;
            button.dataset.time = time;
            button.addEventListener('click', () => {
                const jumpTime = parseFloat(button.dataset.time);
                video.currentTime = jumpTime;
                timeSlider.value = jumpTime;
                sliderCurrentTime.textContent = `${jumpTime.toFixed(1)}s`;
                drawAnalysis(jumpTime);
            });
            shotButtonsContainer.appendChild(button);
        });
    }

    // *** ADDED *** Export Functions
    function downloadFile(content, filename, contentType) {
        const blob = new Blob([content], { type: contentType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    function exportToJSON() {
        const data = {
            timestamp: new Date().toISOString(),
            videoDuration: videoDuration,
            shotVelocityThreshold: SHOT_VELOCITY_THRESHOLD,
            anklePositions: isCorrectionApplied ? correctedAnklePositions : anklePositions,
            wristPositions: isCorrectionApplied ? correctedWristPositions : wristPositions,
            shotTimes: shotTimes,
            correctionApplied: isCorrectionApplied,
            homographyMatrix: homographyMatrix
        };
        
        const jsonString = JSON.stringify(data, null, 2);
        downloadFile(jsonString, 'badminton_analysis.json', 'application/json');
        loadingTxt.textContent = "JSONファイルをエクスポートしました。";
    }

    function exportToCSV() {
        const ankleData = isCorrectionApplied ? correctedAnklePositions : anklePositions;
        const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
        
        let csvContent = "Time,LeftAnkleX,LeftAnkleY,RightAnkleX,RightAnkleY,LeftWristX,LeftWristY,RightWristX,RightWristY\n";
        
        const maxLength = Math.max(ankleData.length, wristData.length);
        for (let i = 0; i < maxLength; i++) {
            const ankle = ankleData[i] || {};
            const wrist = wristData[i] || {};
            const time = ankle.time || wrist.time || '';
            
            csvContent += `${time},`;
            csvContent += `${ankle.leftAnkle?.x || ''},${ankle.leftAnkle?.y || ''},`;
            csvContent += `${ankle.rightAnkle?.x || ''},${ankle.rightAnkle?.y || ''},`;
            csvContent += `${wrist.leftWrist?.x || ''},${wrist.leftWrist?.y || ''},`;
            csvContent += `${wrist.rightWrist?.x || ''},${wrist.rightWrist?.y || ''}\n`;
        }
        
        downloadFile(csvContent, 'badminton_analysis.csv', 'text/csv');
        loadingTxt.textContent = "CSVファイルをエクスポートしました。";
    }

    function exportImages() {
        const images = [];
        
        // Export trajectory canvas
        trajectoryCanvas.toBlob((blob) => {
            images.push({ name: 'trajectory.png', blob });
            
            // Export heatmap canvas
            heatmapCanvas.toBlob((blob2) => {
                images.push({ name: 'heatmap.png', blob: blob2 });
                
                // Export wrist velocity chart
                wristVelocityCanvas.toBlob((blob3) => {
                    images.push({ name: 'wrist_velocity.png', blob: blob3 });
                    
                    // Download each image separately
                    images.forEach((img, index) => {
                        setTimeout(() => {
                            const url = URL.createObjectURL(img.blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = img.name;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                        }, index * 500);
                    });
                    loadingTxt.textContent = "画像ファイルをエクスポートしました。";
                });
            });
        });
    }

    function generateReport() {
        const ankleData = isCorrectionApplied ? correctedAnklePositions : anklePositions;
        const wristData = isCorrectionApplied ? correctedWristPositions : wristPositions;
        
        const report = `バドミントン動作分析レポート
=====================================

分析日時: ${new Date().toLocaleString('ja-JP')}
動画時間: ${videoDuration.toFixed(2)}秒
ショット検出閾値: ${SHOT_VELOCITY_THRESHOLD} ピクセル/秒
座標補正: ${isCorrectionApplied ? '適用済み' : '未適用'}

分析結果:
---------
記録された足首位置データ: ${ankleData.length}ポイント
記録された手首位置データ: ${wristData.length}ポイント
検出されたショット数: ${shotTimes.length}回

ショット時刻:
${shotTimes.map((time, i) => `  ショット${i + 1}: ${time.toFixed(2)}秒`).join('\n')}

統計情報:
---------
最初の記録時刻: ${ankleData.length > 0 ? ankleData[0].time.toFixed(2) : 'N/A'}秒
最後の記録時刻: ${ankleData.length > 0 ? ankleData[ankleData.length - 1].time.toFixed(2) : 'N/A'}秒
平均ショット間隔: ${shotTimes.length > 1 ? ((shotTimes[shotTimes.length - 1] - shotTimes[0]) / (shotTimes.length - 1)).toFixed(2) : 'N/A'}秒

注意: このレポートは自動生成されたものです。
詳細な分析については専門家にご相談ください。
`;

        downloadFile(report, 'badminton_analysis_report.txt', 'text/plain');
        loadingTxt.textContent = "分析レポートを生成しました。";
    }

    // Export button event listeners
    exportJSONButton.addEventListener('click', exportToJSON);
    exportCSVButton.addEventListener('click', exportToCSV);
    exportImageButton.addEventListener('click', exportImages);
    generateReportButton.addEventListener('click', generateReport);

    // *** ADDED *** Help Modal Functions
    const helpModal = document.getElementById('helpModal');
    const helpButton = document.getElementById('helpButton');
    const closeHelpModal = document.getElementById('closeHelpModal');
    
    function showHelpModal() {
        helpModal.classList.remove('hidden');
        document.body.style.overflow = 'hidden';
    }
    
    function hideHelpModal() {
        helpModal.classList.add('hidden');
        document.body.style.overflow = '';
    }
    
    helpButton.addEventListener('click', showHelpModal);
    closeHelpModal.addEventListener('click', hideHelpModal);
    helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) hideHelpModal();
    });
    
    // *** ADDED *** Keyboard Shortcuts
    document.addEventListener('keydown', (e) => {
        // Skip if user is typing in an input field
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        switch(e.key.toLowerCase()) {
            case ' ': // Space - Start/Stop recording
                e.preventDefault();
                if (!startButton.disabled) {
                    startButton.click();
                } else if (!stopButton.disabled) {
                    stopButton.click();
                }
                break;
            case 'a': // A - Analyze
                e.preventDefault();
                if (!analyzeButton.disabled) {
                    analyzeButton.click();
                }
                break;
            case 'h': // H - Help
                e.preventDefault();
                showHelpModal();
                break;
            case 't': // T - Theme toggle
                e.preventDefault();
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                const themes = ['light', 'dark', 'blue', 'green'];
                const currentIndex = themes.indexOf(currentTheme);
                const nextTheme = themes[(currentIndex + 1) % themes.length];
                
                if (nextTheme === 'light') {
                    document.documentElement.removeAttribute('data-theme');
                } else {
                    document.documentElement.setAttribute('data-theme', nextTheme);
                }
                localStorage.setItem('badminton-theme', nextTheme);
                
                document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
                document.querySelector(`[data-theme="${nextTheme}"]`).classList.add('active');
                break;
            case 'e': // E - Export JSON
                e.preventDefault();
                if (anklePositions.length > 0 || wristPositions.length > 0) {
                    exportToJSON();
                }
                break;
            case 'r': // R - Generate Report
                e.preventDefault();
                if (anklePositions.length > 0 || wristPositions.length > 0) {
                    generateReport();
                }
                break;
            case 'escape': // Escape - Close modal
                e.preventDefault();
                hideHelpModal();
                break;
        }
    });

</script>

<!-- ヘルプモーダル -->
<div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center p-4">
    <div class="glass-card max-w-2xl w-full max-h-[90vh] overflow-y-auto p-6">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-2xl font-bold theme-text-accent">使い方ガイド</h2>
            <button id="closeHelpModal" class="theme-text-secondary hover:theme-text-primary transition-colors">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        </div>
        
        <div class="space-y-6">
            <div>
                <h3 class="text-lg font-semibold theme-text-accent mb-2">基本的な使い方</h3>
                <ol class="list-decimal list-inside space-y-2 theme-text-secondary text-sm">
                    <li>動画ファイルを選択してアップロード</li>
                    <li>「録画開始」ボタンで姿勢推定を開始</li>
                    <li>動画終了後、「分析を開始」で軌跡とヒートマップを表示</li>
                    <li>必要に応じてデータをエクスポート</li>
                </ol>
            </div>
            
            <div>
                <h3 class="text-lg font-semibold theme-text-accent mb-2">キーボードショートカット</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-2 text-sm theme-text-secondary">
                    <div><kbd class="glass-button text-xs px-2 py-1">Space</kbd> 録画開始/停止</div>
                    <div><kbd class="glass-button text-xs px-2 py-1">A</kbd> 分析開始</div>
                    <div><kbd class="glass-button text-xs px-2 py-1">H</kbd> ヘルプを表示</div>
                    <div><kbd class="glass-button text-xs px-2 py-1">T</kbd> テーマ切り替え</div>
                    <div><kbd class="glass-button text-xs px-2 py-1">E</kbd> JSONエクスポート</div>
                    <div><kbd class="glass-button text-xs px-2 py-1">R</kbd> レポート生成</div>
                </div>
            </div>
            
            <div>
                <h3 class="text-lg font-semibold theme-text-accent mb-2">機能説明</h3>
                <div class="space-y-3 text-sm theme-text-secondary">
                    <div>
                        <strong>姿勢推定:</strong> MediapipeのPoseLandmarkerを使用して、リアルタイムで身体のキーポイントを検出
                    </div>
                    <div>
                        <strong>ショット検出:</strong> 手首の速度から自動的にショットタイミングを判定
                    </div>
                    <div>
                        <strong>コート補正:</strong> 動画内のコートの歪みを補正して正確な軌跡を表示
                    </div>
                    <div>
                        <strong>比較モード:</strong> 2つの動画を同時に分析して比較が可能
                    </div>
                </div>
            </div>
            
            <div>
                <h3 class="text-lg font-semibold theme-text-accent mb-2">注意事項</h3>
                <ul class="list-disc list-inside space-y-2 theme-text-secondary text-sm">
                    <li>初回のAIモデル読み込みには時間がかかります</li>
                    <li>動画の解像度や品質によって検出精度が変わります</li>
                    <li>明るく、選手が明確に見える動画が推奨されます</li>
                    <li>エクスポート機能はブラウザのダウンロード設定に依存します</li>
                </ul>
            </div>
        </div>
    </div>
</div>

</body>
</html>